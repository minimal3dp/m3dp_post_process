#

**Source:** `2002.01631v1.pdf`
---

## Page 1

Toward Optimal FDM Toolpath Planning with Monte Carlo Tree Search
Chanyeol Yoo1, Samuel Lensgraf2, Robert Fitch1, Lee M. Clemon1, and Ramgopal Mettu3
Abstract— The most widely used methods for toolpath plan-
ning in fused deposition 3D printing slice the input model
into successive 2D layers in order to construct the toolpath.
Unfortunately slicing-based methods can incur a substantial
amount of wasted motion (i.e., the extruder is moving while not
printing), particularly when features of the model are spatially
separated. In recent years we have introduced a new paradigm
that characterizes the space of feasible toolpaths using a
dependency graph on the input model, along with several
algorithms to search this space for toolpaths that optimize
objective functions such as wasted motion or print time. A
natural question that arises is, under what circumstances can we
efﬁciently compute an optimal toolpath? In this paper, we give
an algorithm for computing fused deposition modeling (FDM)
toolpaths that utilizes Monte Carlo Tree Search (MCTS), a
powerful general-purpose method for navigating large search
spaces that is guaranteed to converge to the optimal solution.
Under reasonable assumptions on printer geometry that allow
us to compress the dependency graph, our MCTS-based al-
gorithm converges to ﬁnd the optimal toolpath. We validate
our algorithm on a dataset of 75 models and show it performs
on par with our previous best local search-based algorithm in
terms of toolpath quality. In prior work we speculated that the
performance of local search was near optimal, and we examine
in detail the properties of the models and MCTS executions
that lead to better or worse results than local search.
I. INTRODUCTION
Making 3D printing more efﬁcient is a pressing need in the
area of additive manufacturing [1, 2]. The current sluggish
throughput of 3D printers keeps costs above traditional
manufacturing lines and prevents adoption in medium and
high volume manufacturing. Fabrication speed has long been
and remains a major limiting factor for commercial adoption
of additive manufacturing processes [1–3]. While adoption of
3D printing in medical and aerospace industries is driven by
the low volume and high value products, consumer products
and medium to high volume production depend on rapid
fabrication to meet demand and keep costs competitive.
Thus, tackling the speed of fabrication in 3D printing is a
sector-wide challenge. Current deposition planning methods
in 3D printing depend on 2D layering and complete each
entire layer sequentially, resulting in very long build times
and thus high cost per product. A major contributor to this
additional cost is wasted motion hoping around within each
This research is supported in part by the University of Technology
Sydney, Dartmouth College, and Tulane University.
1School
of
Mechanical
and
Mechatronic
Engineering,
University
of
Technology
Sydney,
NSW
2006,
Australia
{Chanyeol.Yoo,
Lee.Clemon, Robert.Fitch}@uts.edu.au
2Department of Computer Science, Dartmouth College, Hanover, NH
03755, USA Samuel.E.Lensgraf.GR@dartmouth.edu
3Department of Computer Science, Tulane University, New Orleans, LA
70118, USA rmettu@tulane.edu
layer. In this work we greatly reduce this wasted motion by
reexamining the entire deposition planning order.
In prior work we have introduced a framework for opti-
mizing toolpaths with respect to both wasted motion [4, 5]
as well as overall time [6]. We introduced the notion of
a dependency graph of a model to be fabricated, which is
deﬁned by the geometric properties of the extruder head.
Conceptually the dependency graph constrains the order in
which model features must be fabricated and thus allows
us to deﬁne the space of toolpaths which would feasibly
construct the input model on the given printer geometry. We
also gave simple heuristic algorithms based on greedy and
local search to search over the space of toolpaths. These
algorithms all demonstrated that signiﬁcant gains could be
made in toolpath efﬁciency, especially with respect to wasted
motion, if we were not constrained to fabricate layer-by-
layer. A natural question that arises from these approaches is,
what is the optimal toolpath that can be computed for a given
input model and printer geometry? A straightforward, and
discouraging, observation is that planning a single layer of a
fused deposition modeling (FDM) toolpath is easily seen to
reduce to TSP. Thus the scale of planning an entire toolpath,
or even estimating the optimal cost, using approximation
algorithms for TSP or methods such as the Held-Karp
relaxation to obtain LP lower bounds is intractable. In [5] we
explored LP lower bounds to characterize the performance
of local search, but even then were only able to demonstrate
optimality for a few, very small models.
Our main contribution in this paper is to develop the
ﬁrst Monte Carlo Tree Search (MCTS) approach to toolpath
planning. MCTS can be seen as a stochastic branch and
bound approach in which a probabilistic tree search is
used to balance exploration and exploitation in the search
space. MCTS is a ﬂexible, anytime approach to optimization
problems, and is guaranteed to converge to an optimal
solution. To our knowledge, this is the ﬁrst algorithm for
toolpath planning with any guarantees on global optimality.
In recent years MCTS has been shown to be effective
for difﬁcult problems in a number of application areas in
robotics. Of particular note is the Dec-MCTS [7] framework,
which allows MCTS to be solve optimization problems in
an asynchronous, coordinated fashion. By applying the Dec-
MCTS framework, the algorithm then yields an efﬁcient
approach to multi-extruder toolpath planning with guaranteed
convergence, which to our knowledge does not yet exist. In
order to make our algorithm efﬁcient, we also introduce a
novel clustering algorithm on the dependency graph for the
input model. Using a dataset of 75 models, we show that
our MCTS-based approach achieves a substantial reduction
arXiv:2002.01631v1  [cs.RO]  5 Feb 2020


## Page 2

in wasted motion over the layer-by-layer toolpath generated
by Sli3r [8]. The performance of MCTS is interestingly quite
similar to that of our existing local search toolpath planner,
but allows us to more carefully examine the difﬁculty of
toolpath planning for certain types of models. We study
the empirical performance of MCTS and attempt to gather
insights about the optimality of our toolpaths. In particular,
we have strong evidence of convergence for certain models,
and we provide criteria for assessing optimality from our
observations.
II. RELATED WORK
Previous research on toolpath planning and slicing of 3D
printed parts as focused on examining the resolution of the
build relative to the CAD model [9, 10]. This area of work
led to varying layer thickness to increase fabrication speed,
but achieve a speciﬁed surface resolution [9–11]. Others have
focused on adjusting the orientation of the layering through
transitions in multi-axis machines [12], non-planar layers
[12–14], reducing support structures [15], or segmenting
areas within a layer [16]. These works do not consider the
segments within each layer as part of the entire build plan,
but focus on each layer individually. Prior work that focuses
on path planning is primarily concerned with increasing the
speed of the mechanisms or material reaction rates [3, 17],
or varying the thickness of each slice [18] or layering non-
planar surfaces [13, 14]. In contrast to our prior work [4–6],
the former approaches depend on the same sequential and
ordered layering as the original 2.5D methods. Thus, the
approach in this work and our related prior work represents
a fundamental shift away from individual layer-planning
towards a generalized concept of build-planning for additive
manufacturing.
MCTS is a sequential Monte Carlo approach for efﬁcient
planning in large state spaces [19, 20]. It has been used in
motion planning for robot systems in a variety of tasks such
as active information gathering [21–24]. DEC-MCTS is a
decentralised form of this algorithm [7, 25] that has been
used for motion planning in multi-robot systems such as a
pair of robot manipulators [26].
III. PRELIMINARIES AND PROBLEM
FORMULATION
Given an input 3D model for fabrication, as in prior
work we assume that the given model has already been
decomposed into individual, printable line segments. Let this
set of line segments be denoted as L = {ℓ1, · · · , ℓn}. Each
line segment ℓi is an ordered pair (xi,0, xi,1), where xi,· =
[x, y, z]T ∈R3. Given L, we deﬁne the associated set of
contours C as a partition of L into continuous series of line
segments. Intuitively a contour is a series of line segments
in the input model that could be printed in one continuous
extrusion. Note that a contour could be either opened or
closed sequence of line segments.
Let the distance to print a line segment ℓi be denoted
as pi ∈P, and the distance to move the extruder between
a point xj to xk as wxj,xk. We will write the distance
required to travel between line segments ℓi and ℓj as wi,j,
where wi,j
= c(xi,1, xj,0). That is, the travel distance
between two line segments is simply the distance to travel
from the end of the ﬁrst line segment to the beginning of
the second line segment. A toolpath is simply a numbered
ordering of contours π : C →N. The cost of a given toolpath
is the sum of the distances to print line segments and to travel
between line segments.
We note that our deﬁnition of a toolpath does not take
the printer geometry into consideration; indeed a low cost
toolpath may actually not be feasible (i.e., correctly produces
the input model) on all printing platforms. In order to model
the constraints imposed on the toolpath by the geometry of
the printer, in [4] we introduced the notion of a dependency
graph that is deﬁned by the contours in the input model
and printer geometry. We deﬁne the dependency graph D =
(C, E) such that the contours C are the vertices, and a
directed edge (ci, cj) ∈E if ci must be printed prior to
cj in any feasible toolpath. For an edge (ci, cj) ∈E, we
denote ci as the dependee and cj as depender for the pair.
Intuitively, all dependees must be printed before a depender
can be printed. In this paper, we will generate the dependency
graph by considering the bounding volume of the extruder
head, and deﬁning the dependency graph edges (ci, cj) by
whether a ci would be unreachable after printing cj due to
the extruder geometry. We note that the dependency graph
formulation can be made substantially more general if we
wish to take other constraints into consideration.
With these deﬁnitions in mind, we can see that a toolpath
π that feasibly prints the input model must be a sequence
of contours that satisﬁes: i) π contains all contours, and
ii) for any contour ci and any subsequent contour cj in π,
(cj, ci) ̸∈D. In other words, π fabricates the input model
without violating the geometric constraints of the extruder.
The power of this view of the space of all toolpaths is that
we can now deﬁne the optimal toolpath, which is simply
π∗= arg min
π
pi + wi,j.
(1)
This is a toolpath that minimizes movement of the extruder
without printing called extrusionless travel distance. Since
the sum of printing all line segments P is independent of
toolpath, the problem can be re-written more simply as
π∗= arg min
π
wi,j.
(2)
IV. MCTS-BASED TOOLPATH PLANNING
In this section we describe our Monte Carlo Tree Search
(MCTS) toolpath planning framework. We ﬁrst describe the
MCTS approach, and then our adaptation of it for toolpath
planning.
A. Monte Carlo Tree Search
Monte Carlo tree search [19] algorithm is based on biased
search algorithm for ﬁnding an optimal solution asymptoti-
cally. Starting at an initial condition, a tree grows at every
iteration. The algorithm ﬁnds the next best node in a tree to


## Page 3

(a) STL model for ‘four nuts’ model
(b) Dependency graph and highly dependent subgraphs
(c) Dependency graph over highly dependent subgraphs in (b)
Fig. 1.
Example model of ‘four nuts’ (a) image, (b) labelled dependency
graph, and (c) clustered dependency graph from (b)
expand using upper conﬁdence bound (UCB), where UCB
balances between exploitation and exploration. Intuitively,
the node with higher likelihood of ﬁnding a better solution
will be selected. Once a node is selected for expansion, one
or a number of complete sequence is randomly generated
from the node until reaching the end (e.g., end of time
horizon). We call such complete sequence a rollout. Each
random rollout is evaluated and the reward for the rollout is
backprogated up to the root node.
Since the algorithm works by randomly generating at least
one rollout at every iteration, MCTS is an anytime algorithm,
where a solution exists whenever the algorithm is stopped.
This is because any rollout is a valid solution to the problem.
Also, the algorithm will eventually ﬁnd a global optimal
solution as we repeat the process due to its random nature.
Unlike existing Monte Carlo methods, MCTS ﬁnds such
solution faster since it biases its search using UCB.
In this paper, we implement MCTS to ﬁnd a solution that
solves for Problem 2 where we aim to minimise the total
extrusionless travel distance of the tooltip. Given a set of
contours C and dependency graph D, a valid rollout π is a
(a)
(b)
Fig. 2.
An example illusting clustering algorithm in Alg. 1. (1) 16
raw contours are clustered into three highly dependent subgraphs (HDS)
as shown in (b).
Algorithm 1 Dependency Clustering
Input: Dependency graph D
Output: A set of HDS H
1: H ←∅
2: for all dependency depth d ∈{0, 1, · · · } do
3:
H ←{H, contour cluster} where γij ≥0.5
4: end for
5: while H has changed do
6:
for all adjacent subgraph pair hi, hj ∈H do
7:
if γij > Γ then
8:
Merge hj into hi ∈H and delete hj from H
9:
end if
10:
end for
11: end while
sequence of contours in a form
π = ρ1ρ2 · · · ρ|C|
s.t. R(ρi) |= true ∀i ∈[1, |C|],
(3)
where ρi ∈C is the i-th contour to print and R(ρi)
recursively evaluates whether ρi is printable given contours
already printed. Before a contour ρi can be printed, all its
dependees must be printed according to D.
Given a rollout sequence of contours, we compute the
reward r in the form of extrusionless travel distance T. Since
rewards in MCTS must be a value between 0 and 1, the travel
distance is normalised by r =
ˆt−T
ˆt , where ˆt is the upper
bound for travel distance. The upperbound is calculated by
multiplying the longest extrusionless travel distance within
contours C by the total number of contours. Intuitively, the
reward approaches zero as the travel distance approaches the
upper bound and it approaches one as the distance gets closer
to zero travel distance.
B. Dependency Clustering
Although the MCTS-based method eventually ﬁnds an
optimal solution, the running time grows rapidly with the
number of contours. In this section, we present a clustering
algorithm that enables reduction in the number of contour
sets to consider, and allows us to speed up the MCTS sub-
stantially. At a high level, the clustering algorithm identiﬁes
a set of subgraphs of the dependency graph D called highly


## Page 4

(a) ‘four nuts’
(b) ‘four screws’
(c) ‘twisty’
(d) ‘10-ascii’
Fig. 3.
Colored clusters for example parts
dependent subgraphs (HDS) H, where H = {h1, h2, · · · },
hi ∩hj = ∅and S
i hi = C.
Suppose we have a pair of contours such that (ci, cj) ̸∈E
that has more than one contour ck upon which they are
dependent. Then ck is a dependee and ci, cj are dependers.
The set of common dependees of contours ci and cj is
denoted as φij and the sets of all dependees for contours i
and j are denoted as φi and φj, respectively (i.e., φij ⊂φi
and φij ⊂φj). Likewise, ψij and ψi denote the set of
common dependers and set of dependers for contour i.
We can now deﬁne the degree of connectedness γij as
mean

min
|φij|
|φi| , |φij|
|φj|

, min
|ψij|
|ψi| , |ψij|
|ψj|

.
(4)
To gain intuition for this deﬁnition let us consider the
circumstances under which γij = 1. This happens when the
number of common dependers (and dependees) and single-
contour dependers (and dependees) are equal. This means
that ci and cj share all dependers (and dependees).
Deﬁnition 1 (Highly connected pair). A pair of contours
i, j is highly connected if the degree of connectedness γij is
greater than or equal to a constant Γ.
Figure 2a illustrates an example of a dependency graph
where each node represents a contour and an edge repre-
sents dependency where dependee nodes are placed above
dependers. Contours i, j and k have at least one common
dependees. The degree of connectedness between i and j is
0.593, where as that between i and k is only 0.25. In Sec. V
we show that a choice of Γ = 0.5 works well in practice.
Deﬁnition 2 (Highly dependent subgraph (HDS)). A sub-
graph h of dependency graph D is highly dependent if
all pairs of non-dependently adjacent contours with more
than one common dependees or dependers (i.e., |φij| > 0
or |ψij| > 0 for ij-pair) are highly connected.
When γij = 1, a pair is said to be fully connected. A
subgraph is said to be fully dependent when all pairs of non-
dependently adjacent contours are fully connected.
The pseudocode for ﬁnding a set of HDS is shown in
Alg. 1. Initially, we compute the dependency depth for all
contours in dependency graph D. The dependency depth
is the number of edge transitions from root contours. For
example, the dependency depth for contour i in Fig. 2a is 1
and 2 for all dependees. Given all contours at same depth,
we enumerate each pair ij and ﬁnd subgraphs H where the
degree of connectivity is greater than Γ. For every adjacent
subgraphs hi ∈H and hj ∈H, we compute the degree of
connectivity. If the degree is greater than Γ, then this pair is
merged. We repeat this process until no further merging is
possible. We refer to the resulting dependency graph as the
clustered dependency graph. Figure 2 shows how contours
are clustered into three different subgraphs, where Fig. 2b
shows the ﬁnal form of the clustered dependency graph. In
Fig. 3, we demonstrate a various models with HDS.
The overall goal of clustering the dependency graph is
to create subgraphs in which optimization of the toolpath
beyond a layer-by-layer solution is not needed. Each sub-
graph in the clustered dependency graph is highly connected
by construction. Therefore, before a contour at given depth
can be printed, most of its dependees must be printed. In the
extreme case of a fully dependent subgraph where all contour
pairs are fully connected, all dependees must be printed. This
property implies that the optimal printing sequence is such
that each dependee layer (i.e., lower) must be printed in full
before printing the depender layer (i.e., upper).
Such a clustering can be achieved by selecting a strict
enough Γ. Once we identify a set of HDS on the original
dependency graph is identiﬁed, we can then use the clustered
dependency graph as input to MCTS to greatly reduce run-
time. This approach is justiﬁed by the fact that the toolpath
cost within an HDS cannot vary signiﬁcantly and thus the
reduced representation will yield a high quality toolpath. In
our implementation we keep the threshold Γ = 0.5 to achieve
a balance of efﬁciency and approximation.
V. EXPERIMENTAL STUDIES
In this section we present experimental validation of the
algorithm presented in Sec. IV-A. To more closely examine
the performance of MCTS against that of local search, we
chose a subset of 75 models from our prior benchmark of
400+ models [5]. We implemented our MCTS algorithm in
Matlab and measured the reduction in extrusionless travel
relative to our existing local search algorithm and Slic3r as
a baseline comparison. As shown in the boxplots in Fig. 7,
the median reduction of extrusionless travel for local search


## Page 5

(a) Toolpath from Slicer, top view
(b) Toolpath from local search, top view (c) Toolpath and clusters from MCTS, top
view
Fig. 4.
‘Four nuts’ model. Toolpath for building the part by (a)(d) typical layerwise planner, (b)(e) local search from [6], and (c)(f) proposed MCTS,
with red indicating non-printing motion. Solution toolpath for each method is shown in red. Extrusionless distances (in mm) are 16737, 12220 and 11057,
respectively.
(a) Toolpath from Slicer
(b) Toolpath from local search
(c) Toolpath and clusters from MCTS
Fig. 5. ‘Twisty’ model. Toolpath for building the part by (a) typical layerwise planner, (b) local search from [6], and (c) proposed MCTS, with red indicating
non-printing motion. Solution toolpath for each method is shown in red. Extrusionless distances (in mm) are 25021, 11423 and 11306, respectively.
(a) Toolpath from Slicer
(b) Toolpath from local search
(c) Toolpath and clusters from MCTS
Fig. 6.
‘Sponge holder’ model. Toolpath for building the part by (a) Sli3r, (b) local search from [6], and (c) MCTS. Red indicates extrusionless travel,
and multiple colors in (c) indicates HDS components of the dependency graph. Extrusionless distances (in mm) are 84340, 26809 and 33665, respectively.
is about 60% and 55% for MCTS. The running times of
our MCTS algorithm were on the order of around 6 minutes
on average; MCTS was terminated if the solution did not
improve over 5 minutes of search.
While local search is guaranteed only to reach a locally
optimal solution, MCTS is guaranteed to converge asymp-
totically to the global optimum. In our implementation, we
terminated the MCTS search when there is no reduction in
solution cost after 5 minutes.
As noted above, MCTS performs about as well as local
search. Indeed, we noted in prior work [5] that it seemed
difﬁcult to eke any more improvement from local search –
even with an ideal extruder geometry (i.e., no constraints on
reachability), extrusionless travel could only be reduced an
additional few percent relative to Slic3r. We were able to
also show that at least for a few small models, local search
achieved the LP-relaxation lower bound for a linear program
set up to ﬁnd an optimal toolpath in the dependency graph.
We view the MCTS results as an empirical extension of
this reasoning. Since MCTS guarantees eventual convergence
to optimal, we cannot say with certainty that our solutions are
optimal. Indeed, some MCTS toolpaths are slightly poorer
quality than those produced by local search. To study perfor-
mance of MCTS more closely, we partitioned the toolpaths
into three categories corresponding to whether they were
better (over 10% improved), about the same (within 5%),
or worse (over 10% worsen), than the local search toolpaths.
To look at concrete examples of these categories, we chose


## Page 6

Local Search
MCTS
0%
50%
100%
150%
200%
Fig. 7.
Reduction in extrusionless travel of local search [5] and MCTS in
comparison to Slic3r.
0
2000
4000
6000
8000
MCTS iterations
1.1
1.15
1.2
1.25
Distance traveled by MCTS
104
MCTS
Local search
(a) ‘Four nuts’
0
200
400
600
800
1000
MCTS iterations
1
1.2
1.4
1.6
Distance traveled by MCTS
104
MCTS
Local search
(b) ’Twisty’
0
2000
4000
6000
8000
10000
12000
MCTS iterations
2.5
3
3.5
4
Distance traveled by MCTS
104
MCTS
Local search
(c) ‘Sponge holder’
Fig. 8.
extrusionless travel of the MCTS solution in each iteration for
examplar models. Dashed line shows the cost of the local search solution.
exemplar models for each of these categories. Figures 4, 5
and 6 give toolpaths for the chosen model for each category,
respectively, for Sli3r, local search, and MCTS. In Fig. 8, we
show MCTS convergence trends for three different models
in relation to the local search solution cost.
In ‘four nuts’ (Fig. 8a), extrusionless travel rapidly reduces
in the early iterations and quickly outperforms the local
search solution. In ‘twisty’ (Fig. 5), the MCTS solution starts
off worse than the local search and surpasses the local search
solution cost after about 8000 iterations. In ‘sponge holder’
((Fig. 6), the distance reduced gradually but reached a point
of nonimprovement and then timed out after 5 minutes.
To gain insight into the relative behavior of MCTS and
local search, in Fig. 9 we show the parts of dependency
(a) ‘Four nuts’ - MCTS performed better
(b) ’Sponge holder’ - MCTS performed worse
Fig. 9.
Parts of dependency graphs and clusters for two exemplar models
graph and their HDS components for ‘four nuts’ and ‘sponge
holder.’ In ‘four nuts’, the number of contours within a HDS
was much higher than in ‘sponge holder’. Thus the size of
the clustered dependency graph given as input to MCTS is
smaller and results in rapid convergence. In contrast, there
exist many more HDS components in ‘sponge holder.’ This
implies that the convergence rate for ‘sponge holder’ is likely
much slower, with an early termination resulting in a poor
solution. One way to think about the relative performance of
these models is in terms of clustering threshold parameter Γ.
While we set the value of Γ = 0.5 to balance solution quality
and efﬁciency, the best value is in fact model dependent and
for models such as ’sponge holder’ a smaller value would
have resulted in a more tractable dependency graph.
The discussion implies that the solution approaches true
optimal as the number of clusters increases (i.e., running
MCTS over a set of contours, not clusters). However the
convergence rate would become poorer. On the other hand,
we would ﬁnd a converging solution fast with less clusters,
but the solution could be further from true optimal if we may
violate our assumption in Def. 2 by forcing high Γ. Finding
the right Γ to balance remains as open question.
VI. DISCUSSION
In this paper we have developed the ﬁrst provably conver-
gent algorithm for FDM toolpath planning. In order for our
Monte Carlo Tree Search approach to be feasible, we also
developed a novel clustering approach to compress the de-
pendency graph of the input model. We tested our algorithm
over 75 models an observed similar overall performance on
average, but empirically characterized the behavior of MCTS
when it appears to converge.
A natural question is why one would use MCTS over local
search for a given model. Using our empirical studies, it
appears that the output of the clustering step and subsequent
composition of HDS components of the dependency graph
provide guidance as to whether MCTS can achieve conver-
gence. As we saw in our empirical analysis if there enough
HDS components with respect to the size of the dependency
graph then it is highly likely that MCTS will converge to
an optimal toolpath. If the number of HDS components is
too large, or the average size is too small, then MCTS will
have difﬁculty exploring the toolpath space and may perform
worse than local search.


## Page 7

REFERENCES
[1] Y. Huang, M. C. Leu, J. Mazumder, and A. Donmez, “Additive
Manufacturing: Current State, Future Potential, Gaps and Needs, and
Recommendations,” Journal of Manufacturing Science and Engineer-
ing, vol. 137, no. 1, p. 014001, 2015.
[2] T. D. Ngo, A. Kashani, G. Imbalzano, K. T. Q. Nguyen, and D. Hui,
“Additive manufacturing (3d printing): A review of materials, methods,
applications and challenges,” Composites Part B: Engineering, vol.
143, pp. 172–196, June 2018.
[3] J.-P. Kruth, M. Leu, and T. Nakagawa, “Progress in Additive Man-
ufacturing and Rapid Prototyping,” CIRP Annals, vol. 47, no. 2, pp.
525–540, 1998.
[4] S. Lensgraf and R. R. Mettu, “Beyond layers: A 3D-aware toolpath
algorithm for fused ﬁlament fabrication,” in Proc. of IEEE Interna-
tional Conference on Robotics and Automation (ICRA), 2016, pp.
3625–3631.
[5] ——, “An improved toolpath generation algorithm for fused ﬁlament
fabrication,” in Proc. of IEEE International Conference on Robotics
and Automation (ICRA), 2017, pp. 1181–1187.
[6] ——, “Incorporating kinematic properties into fused deposition tool-
path optimization,” in Proc. of IEEE/RSJ International Conference on
Intelligent Robots and Systems (IROS), 2018, pp. 8622–8627.
[7] G. Best, O. Cliff, T. Patten, R. R. Mettu, and R. Fitch, “Dec-
MCTS: Decentralized planning for multi-robot active perception,”
International Journal of Robotics Research, vol. 38, no. 2-3, pp. 316–
337, 2019.
[8] “Slic3r - Open source 3d printing toolbox.”
[9] P. M. Pandey, N. V. Reddy, and S. G. Dhande, “Real time adaptive
slicing for fused deposition modelling,” International Journal of
Machine Tools and Manufacture, vol. 43, no. 1, pp. 61–71, Jan. 2003.
[10] A. Dolenc and I. Mkel, “Slicing procedures for layered manufacturing
techniques,” Computer-Aided Design, vol. 26, no. 2, pp. 119–126, Feb.
1994.
[11] P. Kulkarni and D. Dutta, “An accurate slicing procedure for layered
manufacturing,” Computer-Aided Design, vol. 28, no. 9, pp. 683–697,
Sept. 1996.
[12] M. A. Isa and I. Lazoglu, “Five-axis additive manufacturing of
freeform models through buildup of transition layers,” Journal of
Manufacturing Systems, vol. 50, pp. 69–80, Jan. 2019.
[13] M. K. Micali and D. Dornfeld, “Fully Three-Dimensional Toolpath
Generation for Point-Based Additive Manufacturing Systems,” in Solid
Freeform Fabrication 2016, Austin, Texas, USA, 2016, pp. 36–52.
[14] D. Ahlers, “3D printing of nonplanar layers for smooth surface gen-
eration,” Master’s thesis, University of Hamburg, Hamburg, Germany,
Oct. 2018.
[15] R. Paul and S. Anand, “Optimization of layered manufacturing process
for reducing form errors with minimal support structures,” Journal of
Manufacturing Systems, vol. 36, pp. 231–243, July 2015.
[16] Y.-a. Jin, Y. He, J.-z. Fu, W.-f. Gan, and Z.-w. Lin, “Optimization
of tool-path generation for material extrusion-based additive manufac-
turing technology,” Additive Manufacturing, vol. 1-4, pp. 32–47, Oct.
2014.
[17] J. Go, S. N. Schiffres, A. G. Stevens, and A. J. Hart, “Rate limits of
additive manufacturing by fused ﬁlament fabrication and guidelines
for high-throughput system design,” Additive Manufacturing, vol. 16,
pp. 1–11, Aug. 2017.
[18] W. Ma and P. He, “An adaptive slicing and selective hatching strategy
for layered manufacturing,” Journal of Materials Processing Technol-
ogy, vol. 89-90, pp. 191–197, May 1999.
[19] C. Browne, E. Powley, D. Whitehouse, S. Lucas, P. Cowling, P. Rohlf-
shagen, S. Tavener, D. Perez, S. Samothrakis, and S. Colton, “A
survey of Monte Carlo tree search methods,” IEEE Transactions on
Computational Intelligence and AI in Games, vol. 4, no. 1, pp. 1–43,
2012.
[20] L. Kocsis and C. Szepesv´ari, “Bandit based Monte-Carlo planning,” in
Proc. of European Conference on Machine Learning (ECML), 2006,
pp. 282–293.
[21] T. Patten, W. Martens, and R. Fitch, “Monte Carlo planning for active
object classiﬁcation,” Autonomous Robots, vol. 42, no. 2, pp. 391–421,
2018.
[22] B. Hefferan, O. M. Cliff, and R. Fitch, “Adversarial patrolling with
reactive point processes,” in Proc. of ARAA Australasian Conference
on Robotics and Automation (ACRA), 2016.
[23] B. Kartal, J. Godoy, I. Karamouzas, and S. J. Guy, “Stochastic tree
search with useful cycles for patrolling problems,” in Proc. of IEEE
International Conference on Robotics and Automation (ICRA), 2015,
pp. 1289–1294.
[24] J. Nguyen, N. Lawrance, R. Fitch, and S. Sukkarieh, “Real-time path
planning for long-term information gathering with an aerial glider,”
Autonomous Robots, vol. 40, no. 6, pp. 1017–1039, 2015.
[25] G. Best, M. Forrai, R. R. Mettu, and R. Fitch, “Planning-aware
communication for decentralised multi-robot coordination,” in Proc. of
IEEE International Conference on Robotics and Automation (ICRA),
2018, pp. 1050–1057.
[26] F. Sukkar, G. Best, C. Yoo, and R. Fitch, “Multi-robot region-of-
interest reconstruction with dec-mcts,” in Proc. of IEEE International
Conference on Robotics and Automation (ICRA), 2019.
